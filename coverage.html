
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/MyCarrier-DevOps/slippy-find/cmd/root.go (84.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package cmd provides the CLI commands for slippy-find.
package cmd

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"

        "github.com/spf13/cobra"

        "github.com/MyCarrier-DevOps/slippy-find/internal/domain"
)

// Logger defines the logging interface used by the command.
type Logger interface {
        Info(ctx context.Context, msg string, fields map[string]interface{})
        Debug(ctx context.Context, msg string, fields map[string]interface{})
        Warn(ctx context.Context, msg string, fields map[string]interface{})
        Error(ctx context.Context, msg string, err error, fields map[string]interface{})
}

// Dependencies holds all injectable dependencies for the command.
// This enables testing by allowing mock implementations to be injected.
type Dependencies struct {
        // LoggerFactory creates a logger instance.
        LoggerFactory func() Logger

        // ConfigLoader loads application configuration.
        ConfigLoader func() (*AppConfig, error)

        // GitRepoFactory creates a LocalGitRepository for the given path.
        GitRepoFactory func(path string, log Logger) (domain.LocalGitRepository, error)

        // SlipFinderFactory creates a SlipFinder using the given config.
        SlipFinderFactory func(cfg *AppConfig, log Logger) (domain.SlipFinder, error)

        // ResolverFactory creates a Resolver with the given dependencies.
        ResolverFactory func(
                gitRepo domain.LocalGitRepository,
                finder domain.SlipFinder,
                log Logger,
        ) domain.Resolver

        // OutputWriterFactory creates an OutputWriter.
        OutputWriterFactory func() domain.OutputWriter

        // Stdout is the writer for standard output (for correlation ID).
        Stdout io.Writer

        // Stderr is the writer for standard error (for warnings/errors).
        Stderr io.Writer
}

// AppConfig holds application configuration loaded by ConfigLoader.
type AppConfig struct {
        // ClickHouseConfig is passed to the SlipFinderFactory.
        ClickHouseConfig any

        // PipelineConfig is passed to the SlipFinderFactory.
        PipelineConfig any

        // Database is the database name.
        Database string

        // LogLevel is the log level setting.
        LogLevel string

        // LogAppName is the application name for logging.
        LogAppName string
}

// Command-line flags.
var (
        depth   int
        verbose bool
)

// defaultDeps holds the production dependencies.
// This is set by the production wiring in main or via SetDefaultDependencies.
var defaultDeps *Dependencies

// SetDefaultDependencies sets the default dependencies for production use.
// This should be called from main() before Execute().
func SetDefaultDependencies(deps *Dependencies) <span class="cov8" title="1">{
        defaultDeps = deps
}</span>

// NewRootCmd creates the root command for slippy-find.
func NewRootCmd() *cobra.Command <span class="cov8" title="1">{
        return NewRootCmdWithDeps(defaultDeps)
}</span>

// NewRootCmdWithDeps creates the root command with explicit dependencies.
// This is the primary constructor that enables testing via dependency injection.
func NewRootCmdWithDeps(deps *Dependencies) *cobra.Command <span class="cov8" title="1">{
        rootCmd := &amp;cobra.Command{
                Use:   "slippy-find [path]",
                Short: "Resolve routing slips from local Git repository commit history",
                Long: `slippy-find resolves routing slips using local Git repository commit history.

It walks the commit ancestry from HEAD and queries the slip store to find
a matching routing slip. On success, it outputs only the correlation_id
to stdout for consumption by external systems.

All git context (HEAD SHA, branch, repository name) is derived from the
local repository. The repository name is extracted from the 'origin' remote URL.

Examples:
  # Resolve slip from current directory
  slippy-find

  # Resolve slip from a specific path
  slippy-find /path/to/repo

  # Increase ancestry search depth
  slippy-find --depth 50

  # Enable verbose logging
  slippy-find -v`,
                Args:         cobra.MaximumNArgs(1),
                SilenceUsage: true,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        return runResolve(cmd, args, deps)
                }</span>,
        }

        // Define flags
        <span class="cov8" title="1">rootCmd.Flags().IntVarP(&amp;depth, "depth", "d", domain.DefaultAncestryDepth,
                "Maximum ancestry depth to search for matching slips")
        rootCmd.Flags().BoolVarP(&amp;verbose, "verbose", "v", false,
                "Enable verbose/debug logging")

        return rootCmd</span>
}

// runResolve executes the slip resolution logic with injected dependencies.
func runResolve(cmd *cobra.Command, args []string, deps *Dependencies) error <span class="cov8" title="1">{
        if deps == nil </span><span class="cov8" title="1">{
                return errors.New("dependencies not configured")
        }</span>

        <span class="cov8" title="1">ctx := cmd.Context()
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        // Determine repository path
        <span class="cov8" title="1">repoPath := "."
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                repoPath = args[0]
        }</span>

        // Get stderr for warnings
        <span class="cov8" title="1">stderr := deps.Stderr
        if stderr == nil </span><span class="cov0" title="0">{
                stderr = os.Stderr
        }</span>

        // Set log level based on verbose flag (best-effort)
        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                if err := os.Setenv("LOG_LEVEL", "debug"); err != nil </span><span class="cov0" title="0">{
                        // Best-effort warning: ignore fprintf error as this is non-critical
                        writeWarningf(stderr, "warning: could not set log level: %v\n", err)
                }</span>
        }

        // Initialize logger
        <span class="cov8" title="1">log := deps.LoggerFactory()

        log.Info(ctx, "starting slippy-find", map[string]interface{}{
                "path":    repoPath,
                "depth":   depth,
                "verbose": verbose,
        })

        // Load configuration
        cfg, err := deps.ConfigLoader()
        if err != nil </span><span class="cov8" title="1">{
                log.Error(ctx, "failed to load configuration", err, nil)
                return fmt.Errorf("configuration error: %w", err)
        }</span>

        // Initialize Git repository adapter
        <span class="cov8" title="1">gitRepo, err := deps.GitRepoFactory(repoPath, log)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(ctx, "failed to open git repository", err, map[string]interface{}{
                        "path": repoPath,
                })
                if errors.Is(err, domain.ErrRepositoryNotFound) </span><span class="cov8" title="1">{
                        return fmt.Errorf("not a git repository: %s", repoPath)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := gitRepo.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Warn(ctx, "failed to close git repository", map[string]interface{}{
                                "error": closeErr.Error(),
                        })
                }</span>
        }()

        // Initialize slip finder
        <span class="cov8" title="1">finder, err := deps.SlipFinderFactory(cfg, log)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(ctx, "failed to initialize slip finder", err, nil)
                return fmt.Errorf("database error: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := finder.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Warn(ctx, "failed to close slip finder", map[string]interface{}{
                                "error": closeErr.Error(),
                        })
                }</span>
        }()

        // Create resolver and resolve slip
        <span class="cov8" title="1">resolver := deps.ResolverFactory(gitRepo, finder, log)
        result, err := resolver.Resolve(ctx, domain.ResolveInput{
                Depth: depth,
        })
        if err != nil </span><span class="cov8" title="1">{
                log.Error(ctx, "failed to resolve slip", err, nil)
                if errors.Is(err, domain.ErrNoAncestorSlip) </span><span class="cov8" title="1">{
                        return fmt.Errorf("no slip found in commit ancestry")
                }</span>
                <span class="cov8" title="1">if errors.Is(err, domain.ErrNoRemoteOrigin) </span><span class="cov8" title="1">{
                        return fmt.Errorf("no 'origin' remote configured; cannot determine repository name")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Write correlation ID to stdout
        <span class="cov8" title="1">writer := deps.OutputWriterFactory()
        if err := writer.WriteCorrelationID(result.CorrelationID); err != nil </span><span class="cov8" title="1">{
                log.Error(ctx, "failed to write output", err, nil)
                return fmt.Errorf("output error: %w", err)
        }</span>

        <span class="cov8" title="1">log.Info(ctx, "slip resolution complete", map[string]interface{}{
                "correlation_id": result.CorrelationID,
                "matched_commit": result.MatchedCommit,
                "repository":     result.Repository,
                "resolved_by":    result.ResolvedBy,
        })

        return nil</span>
}

// Execute runs the root command.
func Execute() <span class="cov0" title="0">{
        rootCmd := NewRootCmd()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

// writeWarningf writes a warning message to the given writer.
// This is a best-effort operation; errors are intentionally ignored
// because there is no recovery action if stderr writes fail.
func writeWarningf(w io.Writer, format string, args ...any) <span class="cov8" title="1">{
        _, err := fmt.Fprintf(w, format, args...)
        if err != nil </span><span class="cov8" title="1">{
                // Intentionally ignored: no recovery action for failed stderr writes
                return
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
